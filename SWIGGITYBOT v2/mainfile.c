#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  pneumatics,     sensorDigitalOut)
#pragma config(Sensor, dgtl2,  ArmEnc,         sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  BRI,            sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  BLI,            sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  BRI,            sensorNone)
#pragma config(Sensor, I2C_4,  FRI,            sensorNone)
#pragma config(Motor,  port2,           L1R1,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           FL,            tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port4,           L2R2,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           BL,            tmotorVex393_MC29, PIDControl, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port6,           BR,            tmotorVex393_MC29, PIDControl, driveRight, encoderPort, I2C_2)
#pragma config(Motor,  port8,           L3R3,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           FR,            tmotorVex393_MC29, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//https://www.vexforum.com/index.php/6146-robotc-programming-tips/p2#p53799
//1525
#define MOTOR_NUM               kNumbOfTotalMotors
#define MOTOR_MAX_VALUE         127
#define MOTOR_MIN_VALUE         (-127)
#define MOTOR_DEFAULT_SLEW_RATE 10      // Default will cause 375mS from full fwd to rev
#define MOTOR_FAST_SLEW_RATE    256     // essentially off
#define MOTOR_TASK_DELAY        15      // task 1/frequency in mS (about 66Hz)
#define MOTOR_DEADBAND          10
int motorReq[ MOTOR_NUM ];
int motorSlew[ MOTOR_NUM ];
#pragma platform(VEX2)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "driving.c"
#include "auton.c"
void pre_auton(){

}


task autonomous(){
	startTask(auton);
}


task usercontrol(){
	startTask(driving);
}
task MotorSlewRateTask()
{
    int motorIndex;
    int motorTmp;

    // Initialize stuff
    for(motorIndex=0;motorIndex<MOTOR_NUM;motorIndex++)
        {
        motorReq[motorIndex] = 0;
        motorSlew[motorIndex] = MOTOR_DEFAULT_SLEW_RATE;
        }

    // run task until stopped
    while( true )
        {
        // run loop for every motor
        for( motorIndex=0; motorIndex<MOTOR_NUM; motorIndex++)
            {
            // So we don't keep accessing the internal storage
            motorTmp = motor[ motorIndex ];

            // Do we need to change the motor value ?
            if( motorTmp != motorReq[motorIndex] )
                {
                // increasing motor value
                if( motorReq[motorIndex] > motorTmp )
                    {
                    motorTmp += motorSlew[motorIndex];
                    // limit
                    if( motorTmp > motorReq[motorIndex] )
                        motorTmp = motorReq[motorIndex];
                    }

                // decreasing motor value
                if( motorReq[motorIndex] < motorTmp )
                    {
                    motorTmp -= motorSlew[motorIndex];
                    // limit
                    if( motorTmp < motorReq[motorIndex] )
                        motorTmp = motorReq[motorIndex];
                    }

                // finally set motor
                motor[motorIndex] = motorTmp;
                }
            }

        // Wait approx the speed of motor update over the spi bus
        wait1Msec( MOTOR_TASK_DELAY );
        }
}
