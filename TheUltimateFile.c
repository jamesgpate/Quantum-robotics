#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    pot1,           sensorPotentiometer)
#pragma config(Sensor, in2,    pot2,           sensorPotentiometer)
#pragma config(Sensor, in8,    expVoltage,     sensorAnalog)
#pragma config(Sensor, dgtl1,  limit1,         sensorTouch)
#pragma config(Sensor, dgtl2,  limit2,         sensorTouch)
#pragma config(Sensor, dgtl5,  redLED1,        sensorLEDtoVCC)
#pragma config(Sensor, dgtl6,  redLED2,        sensorLEDtoVCC)
#pragma config(Sensor, dgtl7,  redLED3,        sensorLEDtoVCC)
#pragma config(Sensor, dgtl8,  yellowLED1,     sensorLEDtoVCC)
#pragma config(Sensor, dgtl9,  yellowLED2,     sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, greenLED1,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, greenLED2,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, greenLED3,      sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  hook1,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           frontRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           backRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           frontLeft,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           backLeft,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           arm1,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           arm2,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           arm3,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           hook,          tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//init for motors, sensors, etc
#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "config.h"
#include "Vex_Competition_Includes.c"
#include "AutonomousPrograms.c";//include auton program
#include "driverControl.c";//include driver program
#include "CommandsForControl.c";//include auton commands
void waitForPress(){//for auton selection
	while(nLCDButtons == 0){}
	wait1Msec(5);
}
void waitForRelease(){//for auton selection
	while(nLCDButtons != 0){}
	wait1Msec(5);
}
//
const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;
//
int count = 0;
void pre_auton()//select auton program
{
	bStopTasksBetweenModes = true;
	clearLCDLine(0);
	clearLCDLine(1);
	//
	while(nLCDButtons != centerButton){
		switch(count){
		case 0://auton 1
			displayLCDCenteredString(0, "Turn Left");
			displayLCDCenteredString(1, "<         Enter        >");
			waitForPress();
			if(nLCDButtons == leftButton){
				waitForRelease();
				count = 3;
			}
			else if(nLCDButtons == rightButton){
				waitForRelease();
				count++;
			}
			break;
		case 1://auton 2
			displayLCDCenteredString(0, "Turn Right");
			displayLCDCenteredString(1, "<         Enter        >");
			waitForPress();
			if(nLCDButtons == leftButton){
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton){
				waitForRelease();
				count++;
			}
			break;
		case 2://auton 3
			displayLCDCenteredString(0, "Fence Left");
			displayLCDCenteredString(1, "<         Enter        >");
			waitForPress();
			if(nLCDButtons == leftButton){
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton){
				waitForRelease();
				count++;
			}
			break;
		case 3://auton 4
			displayLCDCenteredString(0, "Fence Right");
			displayLCDCenteredString(1, "<         Enter        >");
			waitForPress();
			if(nLCDButtons == leftButton){
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton){
				waitForRelease();
				count = 0;
			}
			break;
		default:
			count = 0;
			break;
		}
	}
}
task autonomous()
{
	callAutonomous(count);//Runs auton program
}
task usercontrol()
{
	startTask(drivingControl); //Starts driver control
}
